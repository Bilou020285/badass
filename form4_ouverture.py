# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DialogBADASSDialog
                                 A QGIS plugin
 Extention permettant l'accès à l'interface BADASS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Alexandre Humeau
        email                : alexandre.humeau1@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.core import *
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import *
from PyQt5 import QtCore
from PyQt5.QtCore import *
from PyQt5 import QtGui
from PyQt5.QtGui import *
from .form4_ouverture_menu import DialogBADASSForm4OuvertureMenu
from .expression import *
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'form4_ouverture.ui'))

#Changer les paramtres d'entrées du constructeur avec les éléments envoyé à la fentre form3_ouverture
class DialogBADASSForm4Ouverture(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, ouverture_type, modifier, value, parent=None):
        """Constructor."""
        super(DialogBADASSForm4Ouverture, self).__init__(parent)
        #
        self.modifier = modifier
        self.value=value
        #
        self.setupUi(self)

        #On récupère l'instance de la couche t_tranchee
        self.layers = QgsProject.instance().mapLayersByName('t_tranchee')
        #Si l'on modifie une ouverture, alors on charge dans les différents valeurs dans le formulaire
        if self.modifier :
            self.set_form()

        #On initialise un dictionnaire, il sert à conservé les éléments du formaulaire
        self.dict_elements={'tr_id':None, 'tr_num':None, 'tr_long':None, 'tr_larg':None, 'tr_surface':None,'tr_prof_max':None, 'tr_prof_min':None, 'tr_note':None}
        #On initialise un tableau, il sert à savoir quelle element à été modifié
        self.tab_element_modifie=[]

        #Les éléments du tableau ne sont pas clairement définis
        #Le model choisie pour l'instant est le plus adapté à un QTableView
        self.model = QStandardItemModel(5, 3)
        self.tableView_archeo.setModel(self.model)
        #Les données sont bidons, elles permettent d'avoir un aperçu d'un tableau rempli
        for i in range(5):
                for j in range(3):
                    item = QStandardItem(str(i+j))
                    self.model.setItem(i,j,item)
        #Quelques méthodes utiles pour cacher les en-têtes et changer leur contenue
        #self.tableView_archeo.horizontalHeader().setVisible(False)
        #self.ui.tblContents.verticalHeader().setVisible(False)
        #self.model.setHorizontalHeaderLabels(['2','1','2'])

        #Ancien bouton retour, permet d'accèder à un menu qui permet d'accéder aux autres formulaires du niveau 3
        self.menu_bouton.clicked.connect(self.menu)
        #fenetre expression
        self.rechercher.clicked.connect(lambda: expression_dialog(self,iface))
        #boutton ok
        self.buttonBox.accepted.connect(self.ok_clicked)
        #Ecouteur d'evènement pour les object
        #Pour stocker les valeurs du formulaires
        self.numouvert.editingFinished.connect(lambda: self.add_to_dict('tr_num',self.numouvert))
        self.longouvert.valueChanged.connect(lambda: self.add_to_dict('tr_long',self.longouvert))
        self.prof_max_ouvert.valueChanged.connect(lambda: self.add_to_dict('tr_prof_max',self.prof_max_ouvert))
        self.largouvert.valueChanged.connect(lambda: self.add_to_dict('tr_larg',self.largouvert))
        self.prof_min_ouvert.valueChanged.connect(lambda: self.add_to_dict('tr_prof_min',self.prof_min_ouvert))
        self.plainTextEdit.textChanged.connect(lambda: self.add_to_dict('tr_note',self.plainTextEdit))#Commentaire


    #Pour chaque changment dans le formulaire on appele cette méthode
    #Elle va mettre la valeur modifier dans le dictionnaire
    def add_to_dict(self, name, object):
        self.tab_element_modifie.append(name)
        if isinstance(object, QLineEdit):
            try:
                int(object.text())
                is_int=True
                #On verifie si le tr_num est bien un int et si il n'est pas déja présent dans le tableau
                unique=True
                for f in self.layers[0].getFeatures():
                    if f[name] == int(object.text()):
                        unique = False
            except ValueError as e:
                is_int=False
            if is_int and unique:
                self.dict_elements[name]=object.text()
            else:
                self.message()
        elif isinstance(object, QDoubleSpinBox):
            self.dict_elements[name]=object.value()
        elif isinstance(object, QPlainTextEdit):
            self.dict_elements[name]=object.toPlainText()

    #Méthode appelé quand le bouton ok est cliqué et si le formualire est modifier
    def modif_f(self):
        #On Récupère le champs  à modifié
        expression= '"tr_id" = '+ str(self.value)
        request = QgsFeatureRequest().setFilterExpression(expression)
        #pour chaque champs (normalement il y en a qu'un)
        for f in self.layers[0].getFeatures(request):
            #On regarde si on peut editer
            if self.layers[0].isEditable() :
                print('is e')
                #pour tous les éléments dans le dictionnaire, on regarde si ils ont été modifier (si ils sont dans le tabeau modifié)
                for key,value in self.dict_elements.items():
                    if key in self.tab_element_modifie:
                        #Si ils le sont, on effectue la modification
                        f[key] = value
                        print(f[key], '=', value)
                #Et on met à jours le champs
                self.layers[0].updateFeature(f)
            else :
                print('is n')

    #Cette méthode est appelé lors de l'ajout d'une tranchée
    def new_f(self):
        if self.layers[0].isEditable() :
            #On créer un nouveau champs que l'on ajoute à la couche
            f = QgsFeature()
            #On utilise un tableau a=intermédiaire, car setAttributes n'accespte pas dict_elements.values()
            tab_value=[]
            for element in self.dict_elements.values():tab_value.append(element)
            f.setAttributes(tab_value)
            self.layers[0].addFeatures([f])
            print('esp')
            #
            f.setFields(self.layers[0].fields())

    def menu(self):
        self.fenetre4_ouverture_menu = DialogBADASSForm4OuvertureMenu()
        # show the dialog
        self.fenetre4_ouverture_menu.show()

    #Lors d'une modfication d'ouverture
    def set_form(self):
        try:
            expression= '"tr_id" = '+ str(self.value)
            request = QgsFeatureRequest().setFilterExpression(expression)
            for f in self.layers[0].getFeatures(request):
            #Puis on place les valeurs dans les objets
            #
                if str(f['tr_num']) =='NULL':
                    numouvert=''
                else:
                    numouvert=(str(f['tr_num']))
                self.numouvert.setText(numouvert)
                #
                if str(f['tr_long']) =='NULL':
                    longouvert=0.0
                else:
                    longouvert=float(str(f['tr_long']))
                self.longouvert.setValue(longouvert)
                    #
                if str(f['tr_prof_max']) =='NULL':
                    prof_max_ouvert=0.0
                else:
                    prof_max_ouvert=float(str(f['tr_prof_max']))
                self.prof_max_ouvert.setValue(prof_max_ouvert)
                #
                if str(f['tr_larg']) =='NULL':
                    largouvert=0.0
                else:
                    largouvert=float(str(f['tr_larg']))
                self.largouvert.setValue(largouvert)
                #
                if str(f['tr_prof_min']) =='NULL':
                    prof_min_ouvert=0.0
                else:
                    prof_min_ouvert=float(str(f['tr_prof_min']))
                self.prof_min_ouvert.setValue(prof_min_ouvert)
                #
                if str(f['tr_note']) =='NULL':
                    plainTextEdit=''
                else:
                    plainTextEdit=(str(f['tr_note']))
                self.plainTextEdit.setPlainText(plainTextEdit)#Commentaire
        except Exception as e:
            raise

    #Lorsque le bouton ok est cliqué
    def ok_clicked(self):
        if self.modifier:
            self.modif_f()
        else:
            self.new_f()

    #Message par rapport au numéro d'ouverture
    def message(self):
        msgBox = QMessageBox()
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle("Information !")
        msgBox.setText("Le numéro d'ouverture n'est pas un entier ou est déja présent dans le tableau.")
        msgBox.setStandardButtons(QMessageBox.Ok)
        #msgBox.buttonClicked.connect(msgButtonClick)

        returnValue = msgBox.exec()
        if returnValue == QMessageBox.Ok:
            print('Suppression confirmé')

"""layers = QgsProject.instance().mapLayersByName('t_sondage')
for i in range(110,150,1):
    dict_elements={'sd_id':None, 'sd_num':i, 'sd_numtr':None, 'sd_type':None, 'sd_prof':None,'sd_note':None}
    f = QgsFeature()
    tab_value=[]
    for element in dict_elements.values():tab_value.append(element)
    f.setAttributes(tab_value)
    layers[0].addFeatures([f])"""
