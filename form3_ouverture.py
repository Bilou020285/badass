# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DialogBADASSDialog
                                 A QGIS plugin
 Extention permettant l'accès à l'interface BADASS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Alexandre Humeau
        email                : alexandre.humeau1@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from .form4_ouverture import DialogBADASSForm4Ouverture
from PyQt5.QtWidgets import *
from PyQt5 import QtCore
from PyQt5.QtCore import *
from PyQt5 import QtGui
from PyQt5.QtGui import *
from PyQt5.QtSql import QSqlDatabase, QSqlQuery, QSqlQueryModel
from .expression import *
from .fonction_bdd import *
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'form3_ouverture.ui'))


class DialogBADASSForm3Ouverture(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, conn, cur, parent=None):
        """Constructor."""
        super(DialogBADASSForm3Ouverture, self).__init__(parent)
        #
        #On récupère
        self.iface = iface
        self.conn=conn
        self.cur=cur
        self.setupUi(self)
        self.filtre_type="tranchée de diagnostic"


        #On charge le tableau liée au filtre par défaut
        self.charge_tranchee_de_diagnostic_tab()
        #Lorsque l'élément de la QCombobox change le tableau va changer en conséquence
        self.typouvert.currentTextChanged.connect(self.combobox_changed)
        #Ecouteur d'evènement sur le tableau (double clique)
        self.tableView_archeo.doubleClicked.connect(self.modifier_ouverture)
        #Ecouteur d'evènement sur le tableau (simple clique)
        self.tableView_archeo.clicked.connect(self.select_feature_tranchee)
        #Ecouteur d'evènement sur le bouton nouvelle ouverture
        self.new_ouverture_bouton.clicked.connect(self.set_ouverture)
        #add line
        #fenetre expression
        self.rechercher.clicked.connect(lambda: expression_dialog(self,self.iface))
    """
    Les méthodes suivantes vont permettre de changer le tableau affiché en fonction du type de filtre selectionner
    """
    def combobox_changed(self, value):
        #On modifie la valeur du filtre de type
        self.filtre_type = value
        #On change le tableau
        self.change_tab()

    def change_tab(self):
        #On cherche à soir quelle est le filtre type afin d'appelé la méthode approprié
        if self.filtre_type == 'tranchée de diagnostic':
            self.charge_tranchee_de_diagnostic_tab()
        elif self.filtre_type == 'zone':
            self.charge_zone_tab()
        elif self.filtre_type == 'secteur':
            self.charge_secteur_tab()
        elif self.filtre_type == 'sondage':
            self.charge_sondage_tab()
        elif self.filtre_type == 'palier':
            self.charge_palier_tab()
        elif self.filtre_type == 'berme':
            self.charge_berme_tab()

    def charge_tranchee_de_diagnostic_tab(self):
        #QSqlQueryModel, QSqlTableModel et QSqlRelationalTableModel
        """
        QSqlQueryModel	A read-only model based on an arbitrary SQL query.
        QSqlTableModel	A read-write model that works on a single table.
        QSqlRelationalTableModel	A QSqlTableModel subclass with foreign key support"""
        #QSqlQueryModel
        try:
            #La connexion à la base de données est facultatifs
            #La connexion par défaut est utilisée
            q = QSqlQuery()
            q.prepare("select * from t_tranchee;")
            q.exec()
            #


            self.model = QSqlQueryModel()
            self.model.setQuery(q)

            """self.proxy = QSortFilterProxyModel()

            self.proxy.removeColumns(3,1)

            self.proxy.setSourceModel(self.model)
            self.tableView_archeo.setModel(self.proxy)"""
            self.tableView_archeo.setModel(self.model)
            #On cache la colonne geom
            self.tableView_archeo.setColumnHidden(8,True)
            #On definit les noms des colonnes
            self.model.setHeaderData(0,Qt.Horizontal,'id')
            self.model.setHeaderData(1,Qt.Horizontal,"nuémro d'ouverture")
            self.model.setHeaderData(2,Qt.Horizontal,'longueur')
            self.model.setHeaderData(3,Qt.Horizontal,'largeur')
            self.model.setHeaderData(4,Qt.Horizontal,'surface')
            self.model.setHeaderData(5,Qt.Horizontal,'profondeur min')
            self.model.setHeaderData(6,Qt.Horizontal,'profondeur max')
            self.model.setHeaderData(7,Qt.Horizontal,'commentaire')
            #On affiche les chagement de la table
            self.tableView_archeo.show()
            #self.model.setHorizontalHeaderLabels(range(7))

        except Exception as e:
            raise



    def charge_zone_tab(self):
        #Les éléments du tableau ne sont pas clairement définis
        #Le model choisie pour l'instant est le plus adapté à un QTableView
        self.model = QStandardItemModel(2, 3)
        self.tableView_archeo.setModel(self.model)
        #Les données sont bidons, elles permettent d'avoir un aperçu d'un tableau rempli
        for i in range(2):
                for j in range(3):
                    item = QStandardItem(str(i+j))
                    self.model.setItem(i,j,item)
        #Quelques méthodes utiles pour cacher les en-têtes et changer leur contenue
        #self.tableView_archeo.horizontalHeader().setVisible(False)
        #self.ui.tblContents.verticalHeader().setVisible(False)
        #self.model.setHorizontalHeaderLabels(['2','1','2'])

    def charge_secteur_tab(self):
        try:
            #La connexion à la base de données est facultatifs
            #La connexion par défaut est utilisée
            q = QSqlQuery()
            q.prepare("select * from ouverture;")
            q.exec()
            #
            self.model = QSqlQueryModel()
            self.model.setQuery(q)
            self.tableView_archeo.setModel(self.model)
            self.tableView_archeo.show()
            #self.model.setHorizontalHeaderLabels(range(7))
        except Exception as e:
            raise

    def charge_sondage_tab(self):
        try:
            #La connexion à la base de données est facultatifs
            #La connexion par défaut est utilisée
            q = QSqlQuery()
            q.prepare("select * from t_sondage;")
            q.exec()
            #
            self.model = QSqlQueryModel()
            self.model.setQuery(q)
            self.tableView_archeo.setModel(self.model)
            self.tableView_archeo.show()
            #self.model.setHorizontalHeaderLabels(range(7))
        except Exception as e:
            raise

    def charge_palier_tab(self):
        #Les éléments du tableau ne sont pas clairement définis
        #Le model choisie pour l'instant est le plus adapté à un QTableView
        self.model = QStandardItemModel(1, 9)
        self.tableView_archeo.setModel(self.model)
        #Les données sont bidons, elles permettent d'avoir un aperçu d'un tableau rempli
        for i in range(1):
                for j in range(9):
                    item = QStandardItem(str(i+j))
                    self.model.setItem(i,j,item)
        #Quelques méthodes utiles pour cacher les en-têtes et changer leur contenue
        #self.tableView_archeo.horizontalHeader().setVisible(False)
        #self.ui.tblContents.verticalHeader().setVisible(False)
        #model.setHorizontalHeaderLabels(['2','1','2'])

    def charge_berme_tab(self):
        #Les éléments du tableau ne sont pas clairement définis
        #Le model choisie pour l'instant est le plus adapté à un QTableView
        self.model = QStandardItemModel(8, 8)
        self.tableView_archeo.setModel(self.model)
        #Les données sont bidons, elles permettent d'avoir un aperçu d'un tableau rempli
        for i in range(8):
                for j in range(8):
                    item = QStandardItem(str(i+j))
                    self.model.setItem(i,j,item)
        #Quelques méthodes utiles pour cacher les en-têtes et changer leur contenue
        #self.tableView_archeo.horizontalHeader().setVisible(False)
        #self.ui.tblContents.verticalHeader().setVisible(False)
        #model.setHorizontalHeaderLabels(['2','1','2'])

    """
    Les méthodes suivantes vont permettre de d'appeler la bonne fenetre form4_ouverture
    Soit quant le bouton nouvelle entité est pressé
    Soit quand une ligne du tableau est selectionner(afin d'éditer les données)
    """
    def set_ouverture(self, modifier = False, value=None):
        self.fenetre4_ouverture = DialogBADASSForm4Ouverture(self.filtre_type, modifier, value)
        # show the dialog
        self.fenetre4_ouverture.show()

    def modifier_ouverture(self):
        #Récupère la case qui à été double cliqué
        idx = self.tableView_archeo.selectionModel().selectedIndexes()
        #row_number = idx.row()
        #column_number = idx.column()
        #On récupère la valeur du champs de la colonne 1 (car il est définit à chaque ajout d'ouverture)
        value=idx[0].sibling(idx[0].row(),0).data()
        #
        modifier = True
        #On ouvre la fenetre form4_ouverture
        self.set_ouverture(modifier, value)

    def select_feature_tranchee(self):
        #Pour l'instant une seul cellule ne peut être selectionner
        #Sinon la fonction n'est pas appelé
        tab_expression=[]
        expressions=''
        #Pour toutes les cases selectionner
        for idx in self.tableView_archeo.selectionModel().selectedIndexes():
            #On récupère la valeur du champs tr_num de la ligne selectionner (ce champs est unique)
            value=idx.sibling(idx.row(),0).data()
            # On créer l'expression
            tab_expression.append('"id_ouverture"='+str(value))
            #On selectionne

        for i in range(len(tab_expression)-1):
            expressions+=tab_expression[i]+' or '
        expressions+=tab_expression[len(tab_expression)-1]
        #On get la couche actuelle
        layer = self.iface.activeLayer()
        #
        layer.selectByExpression(expressions)
        #layer.setSelectedFeatures([feature.id()])

"""
#On récupère le nom des colonnes
colonne_names=get_name_colonne(self.cur,'t_tranchee')
#On récupère le contenue de la table
try:
    sql = "SELECT * FROM t_tranchee;"
    self.cur.execute(sql)
    valeurs=self.cur.fetchall()
    print(valeurs)
except Exception as e:
    raise
#
self.model = QStandardItemModel(len(valeurs), len(colonne_names))
self.tableView_archeo.setModel(self.model)
#Les données sont bidons, elles permettent d'avoir un aperçu d'un tableau rempli
#-1 pour enlever la colonne geométrie
for i in range(len(valeurs)-1):
        for j in range(len(colonne_names)-1):
            item = QStandardItem(str(valeurs[i][j]))
            self.model.setItem(i,j,item)
#On redéfini le nom de l'en-tête horizontal
self.model.setHorizontalHeaderLabels(colonne_names)
"""
