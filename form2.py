# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DialogBADASSDialog
                                 A QGIS plugin
 Extention permettant l'accès à l'interface BADASS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Alexandre Humeau
        email                : alexandre.humeau1@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import *
#On import les class pour l'intansiation des autres fenetre
from .form3_mobilier import DialogBADASSForm3Mobilier
from .form3_docs import DialogBADASSForm3Docs
from .form3_entite_archeo import DialogBADASSForm3EntiteArcheo
from .form3_ouverture import DialogBADASSForm3Ouverture
from .form3_strati import DialogBADASSForm3Strati
from .form3_technique import DialogBADASSForm3Technique
#
from qgis.core import *
from qgis.gui import *
import random
import time


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'form2.ui'))


class DialogBADASSForm2(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self,iface, conn, db, parent=None):
        """Constructor."""
        super(DialogBADASSForm2, self).__init__(parent)
        #On recupère la connexion et un curseur
        self.iface=iface
        self.conn = conn
        self.cur = conn.cursor()
        self.db= db
        self.db.open()
        #Par défaut on suppose que la couche emprise n'est pas vide
        self.is_layer_emprise_empty = False
        #
        self.setupUi(self)
        #On récupère les infos de la table emprise et on les mets dans le formulaire
        self.get_emprise()
        #ecouteur d'évenement sur les différents boutons données
        self.ouverture_bouton.clicked.connect(self.ouverture)
        self.Archeo_bouton.clicked.connect(self.entite_archeo)
        self.strati_bouton.clicked.connect(self.strati)
        self.technique_bouton.clicked.connect(self.technique)
        self.Mobilier_bouton.clicked.connect(self.mobilier)
        self.doc_bouton.clicked.connect(self.docs)
        #
        #Test
        #1
        #self.valid.clicked.connect(self.add_point)
        #2

        #self.valid.clicked.connect(self.point_localisation)
        self.valid.clicked.connect(self.add_point)

        #
        #https://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/geometry.html
        

    def mobilier(self):
        self.fenetre3_mobilier = DialogBADASSForm3Mobilier()
        # show the dialog
        self.fenetre3_mobilier.show()

    def docs(self):
        self.fenetre3_docs = DialogBADASSForm3Docs()
        # show the dialog
        self.fenetre3_docs.show()

    def entite_archeo(self):
        self.fenetre3_entite_archeo = DialogBADASSForm3EntiteArcheo()
        # show the dialog
        self.fenetre3_entite_archeo.show()

    def ouverture(self):
        self.fenetre3_ouverture = DialogBADASSForm3Ouverture(self.iface, self.conn, self.cur)
        # show the dialog
        self.fenetre3_ouverture.show()


    def strati(self):
        self.fenetre3_strati = DialogBADASSForm3Strati()
        # show the dialog
        self.fenetre3_strati.show()

    def technique(self):
        self.fenetre3_technique = DialogBADASSForm3Technique()
        # show the dialog
        self.fenetre3_technique.show()

    #méthode d'ajout du code sql à la table emprise
    def get_emprise(self):
        try:
            #On commence par résupérer les infos dans la table emprise
            sql="SELECT * FROM 'emprise';"
            self.cur.execute(sql)
            self.conn.commit()
            res_emprise=self.cur.fetchall()
            if res_emprise:
                numope=res_emprise[0][1]
                nomope=res_emprise[0][2]
                ro=res_emprise[0][7]
                typope=(res_emprise[0][3]).lower()
                numoa=res_emprise[0][5]
                numprescr=res_emprise[0][6]
                #On récupère les texte de la QCombobox
                tab_qcombobox_element=[]
                for i in range(self.typope.count()):
                    tab_qcombobox_element.append(self.typope.itemText(i))
                #On regarde si le texte récup est dans la QCombobox
                if typope not in tab_qcombobox_element:
                    #Si non on l'ajoute comme dans la QCombobox et on le positionne comme texte actuelle
                    self.typope.addItem(typope)
                #On ajoute les données au formulaire
                self.typope.setCurrentText(typope)
                self.numope.setText(numope)
                self.nomope_lbl_2.setPlainText(nomope)
                self.ro.setText(ro)
                #typemp = 'jsp'
                self.numoa.setText(numoa)
                self.numprescr.setText(numprescr)
            else:
                #
                self.is_layer_emprise_empty = True
        except Exception as e:
            raise

    def set_emprise_change(self):
        try:
            #On commence par récuperer les paramètres
            numope = self.numope.text()
            nomope = self.nomope_lbl_2.toPlainText()
            typope = self.typope.currentText()
            numoa = self.numoa.text()
            numprescr = self.numprescr.text()
            ro = self.ro.text()
            #Puis on initialise les champs
            #et on ajoute le
            sql = "UPDATE 'emprise' SET numope = ?, nomope = ?, typope = ?, numoa = ?, numprescr = ?, ro = ? WHERE id_emprise = 0"
            value = (numope, nomope, typope, numoa, numprescr, ro)
            self.cur.execute(sql, value)
            self.conn.commit()
        except Exception as e:
            raise


    #Lorsque la fenetre se ferme
    def closeEvent(self, event):
        #La mise à jour des valuers de la tables emprise se fait ici
        #
        if not self.is_layer_emprise_empty:
            self.set_emprise_change()
        #On ferme le curseur et la connexion
        self.cur.close()
        self.conn.close()
        self.db.close()
        event.accept() # let the window close

    #Test add point
    def add_point(self):
        #self.label.setParent(NULL)
        #add point
        layer = self.iface.activeLayer()
        pr = layer.dataProvider()
        f = QgsFeature()
        f.setGeometry(QgsGeometry.fromMultiPolygonXY([
            [[QgsPointXY(2, 3),
              QgsPointXY(4, 5),
              QgsPointXY(1, 3),
              QgsPointXY(1, 1)]],
            [[QgsPointXY(2, 2),
              QgsPointXY(3, 3),
              QgsPointXY(3, 1),
              QgsPointXY(2, 2)]]
        ]))
        #f.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x,y)))
        #f.setAttributes(["Ada L."+str(random.randint(0, 100)), random.randint(0, 100), 0.3])
        f.setAttributes([1,11,2.2,3.3,4.4,5.5])
        #"id_log" INTEGER PRIMARY KEY,"numlog" INTEGER,"numtr" INTEGER,"numsd" INTEGER,"alti" REAL,"prof_log" REAL,"zmin_log" REAL,"objectif_log" TEXT,"note_log" TEXT
        pr.addFeature(f)

        #Puis on met la couche à jour
        layer.updateExtents

        #
        #self.select_point()

    def add_polygon(self):

        #add point
        layer = self.iface.activeLayer()
        pr = layer.dataProvider()
        f = QgsFeature()
        #f.setGeometry(QgsPoint(x, y, 3))
        #f.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x,y)))
        print(QgsWkbTypes.displayString(layer.wkbType()))
        if QgsWkbTypes.displayString(layer.wkbType()) == 'Polygon':
            f.setGeometry(QgsGeometry.fromPolygonXY([[QgsPointXY(self.dict_points['x1'], self.dict_points['y1']), QgsPointXY(self.dict_points['x2'], self.dict_points['y2']), QgsPointXY(self.dict_points['x3'], self.dict_points['y3'])]]))
        elif QgsWkbTypes.displayString(layer.wkbType()) == 'MultiPolygon':
            f.setGeometry(QgsGeometry.fromMultiPolygonXY([
            [[QgsPointXY(1, 1),
            QgsPointXY(2, 2),
            QgsPointXY(1, 2),
            QgsPointXY(1, 1)]],
            [[QgsPointXY(2, 2),
            QgsPointXY(3, 3),
            QgsPointXY(3, 1),
            QgsPointXY(2, 2)]]
            ]))

        f.setAttributes(["Ada L."+str(random.randint(0, 100)), random.randint(0, 100), 0.3])
        pr.addFeature(f)

        #Puis on met la couche à jour
        layer.updateExtents
        #
    #Test select point
    def select_point(self):
        #On recupère la couche active
        layer = self.iface.activeLayer()
        #On récupère les champs qui sont sélectionné(avec la sélection des entités en jaune)
        #Sous forme d'iter
        """Voir la partie 'Itérer sur une couche vecteur'
        https://docs.qgis.org/2.8/fr/docs/pyqgis_developer_cookbook/vector.html """

        #iter = layer.getSelectedFeatures()
        selection = layer.selectedFeatures()
        #On recupère les champs contenue dans l'iter
        for feature in selection:
            # retrieve every feature with its geometry and attributes
            # fetch geometry
            geom = feature.geometry()
            #self.label.setText(str(i))
            #self.label_x.setText(str(geom.asPolyline()[0].x()))
            #self.label_x.setText(str(geom.asPoint().x()))
            self.label.setText(str(feature['name'])+str(feature['size']))

    #
    def point_localisation(self):

        self.canvas = self.iface.mapCanvas()
        # this QGIS tool emits as QgsPoint after each click on the map canvas
        self.pointTool = QgsMapToolEmitPoint(self.canvas)
        #setMapTool definit le tool utiliser sur le canva
        self.canvas.setMapTool(self.pointTool)
        #
        self.pointTool.canvasClicked.connect(self.display_point)
        self.i=0
        self.label.setText("point_localisation")
        print("point_localisation")


    #
    def display_point(self, point, mouse_button):
        if self.i==0:
            self.dict_points={}
        self.i+=1
        self.label.setText("P: {:.4f}, {:.4f}".format(point.x(), point.y())+" i : "+str(self.i))
        print("Map Coordinates: {:.4f}, {:.4f}".format(point.x(), point.y()))
        self.dict_points['x'+str(self.i)]=point.x()
        self.dict_points['y'+str(self.i)]=point.y()
        #UNLOAD
        if self.i>=3:
            self.add_polygon()
            self.canvas.unsetMapTool(self.pointTool)
